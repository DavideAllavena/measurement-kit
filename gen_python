#!/usr/bin/env python

#
# Copyright (c) 2013, 2014
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

def python_type(types, name):
    return types.get(name, name)

def gen_python_imports(stream):
    stream.write("import _ctypes\n")
    stream.write("import ctypes\n")
    stream.write("import logging\n")
    stream.write("import os\n")
    stream.write("import sys\n")
    stream.write("\n")
    stream.write('if sys.platform == "darwin":\n')
    stream.write('    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.dylib.3"\n')
    stream.write("else:\n")
    stream.write('    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.so.3"\n')
    stream.write("\n")
    stream.write("LIBNEUBOT = ctypes.CDLL(LIBNEUBOT_NAME)\n\n")

def gen_python_prototype(stream, types, class_name, method_info):

    if method_info[0] == "__construct__":
        retval = class_name + "_p"
        funcname = class_name + "_construct"

        # Generate the slots
        args__ = method_info[1:]
        args = []
        for argtype, argname in args__:
            if argtype.startswith("slot_"):
                for slotname in argname:
                    args.append(("NEUBOT_" + argtype.upper(), slotname))
                args.append(("Object", "opaque"))
            else:
                args.append((argtype, argname))

    elif method_info[0] == "__destruct__":
        retval = "void"
        funcname = class_name + "_" + method_info[1]
        args = [(class_name + "_p", "self")]

    else:
        retval = method_info[0]
        funcname = class_name + "_" + method_info[1]

        # Generate the hooks
        args__ = method_info[2:]
        args = []
        for argtype, argname in args__:
            if argtype.startswith("hook_"):
                for hookname in argname:
                    args.append(("NEUBOT_" + argtype.upper(), hookname))
                args.append(("Object", "opaque"))
            else:
                args.append((argtype, argname))

        args.insert(0, (class_name + "_p", "self"))

    stream.write("\n\n")

    if retval != "void":
        stream.write("LIBNEUBOT.%s.restype = %s\n" % (funcname,
          python_type(types, retval)))

    stream.write("LIBNEUBOT.%s.argtypes = (\n" % funcname)
    for argtype, _ in args:
        argtype = python_type(types, argtype)
        stream.write("    %s,\n" % argtype)
    stream.write(")\n")

    stream.write("\n")
    for argtype, argname in args:

        if argtype.endswith("_SLOT_VO"):
            stream.write("""\
def %s_%s_slot_vo(selfptr):
    try:
        selfptr.%s()
    except (KeyboardInterrupt, SystemExit):
        DIE(0)
    except:
        logging.error("Unhandled exception", exc_info=1)
        DIE(1)\n
%s_%s_SLOT_VO = NEUBOT_SLOT_VO(
    %s_%s_slot_vo
)\n
""" % (class_name, argname, argname, class_name.upper(), argname.upper(),
       class_name, argname))
            continue

        if argtype.endswith("_HOOK_VO"):
            stream.write("""\
def %s_%s_hook_vo(closure):
    _ctypes.Py_DECREF(closure)
    try:
        closure.functions["%s"](closure.opaque)
    except (KeyboardInterrupt, SystemExit):
        DIE(0)
    except:
        logging.error("Unhandled exception", exc_info=1)
        DIE(1)\n
%s_%s_HOOK_VO = NEUBOT_HOOK_VO(
    %s_%s_hook_vo
)\n
""" % (funcname, argname, argname, funcname.upper(), argname.upper(),
       funcname, argname))
            continue

        if argtype.endswith("_HOOK_VOS"):
            stream.write("""\
def %s_%s_hook_vos(closure, string):
    _ctypes.Py_DECREF(closure)
    try:
        closure.functions["%s"](closure.opaque, string)
    except (KeyboardInterrupt, SystemExit):
        DIE(0)
    except:
        logging.error("Unhandled exception", exc_info=1)
        DIE(1)\n
%s_%s_HOOK_VOS = NEUBOT_HOOK_VOS(
    %s_%s_hook_vos
)\n
""" % (funcname, argname, argname, funcname.upper(), argname.upper(),
       funcname, argname))
            continue

def gen_python_func_top(stream, types, retval_type, func_name, arguments):
    stream.write("    ")
    nwritten = 4
    stream.write("def ")
    nwritten += 4
    stream.write(func_name)
    nwritten += len(func_name)
    stream.write("(")
    nwritten += 1
    if arguments:
        for index, arg in enumerate(arguments):
            if index > 0:
                stream.write(",")
                nwritten += 1
            _, argname = arg
            if nwritten + len(argname) >= 75:
                stream.write("\n")
                stream.write("          ")
                nwritten = 10
            elif index > 0:
                stream.write(" ")
                nwritten += 1
            stream.write(argname)
            nwritten += len(argname)
    else:
        stream.write("")
    stream.write("):\n")

def gen_python_func_bottom(stream):
    stream.write("\n")

def gen_py_slot(stream, class_name, slot_type, slot_name, destructor_name):
    if slot_type != "slot_vo":
        raise RuntimeError("unrecognised slot type")
    stream.write("    ")
    stream.write("def %s(self):\n" % slot_name)
    stream.write("        pass\n")
    stream.write("\n")

def gen_python_callfunc(stream, nwritten, func_name, args):
    stream.write(func_name)
    nwritten += len(func_name)
    stream.write("(")
    nwritten += 1
    for index, arg in enumerate(args):
        argtype, argname = arg
        if index > 0:
            stream.write(",")
            nwritten += 1
        if argtype and argtype.endswith("_p"):
            argname = argname + ".context_"
        if nwritten + len(argname) >= 78:
            stream.write("\n")
            stream.write("          ")
            nwritten = 10
        elif index > 0:
            stream.write(" ")
            nwritten += 1
        stream.write(argname)
        nwritten += len(argname)
    stream.write(")")

def gen_python_init(stream, types, class_name, struct_name, init_args,
      destructor_name):

    # Generate the slots
    py_args = []
    c_args = []
    for argtype, argname in init_args:
        if argtype.startswith("slot_"):
            have_slots = 1
            for slotname in argname:
                gen_py_slot(stream, class_name, argtype, slotname,
                  destructor_name)
                c_args.append(("NEUBOT_" + argtype.upper(),
                  struct_name.upper() + "_" + slotname.upper() + "_" +
                  argtype.upper()))
            c_args.append(("Object", "self"))
        else:
            py_args.append((argtype, argname))
            c_args.append((argtype, argname))

    py_args.insert(0, ("Object", "self"))
    gen_python_func_top(stream, types, None, "__init__", py_args)

    stream.write("        ")
    nwritten = 8
    stream.write("self.context_ = ")
    nwritten += 17
    gen_python_callfunc(stream, nwritten, "LIBNEUBOT.%s_construct"
      % struct_name, c_args)
    stream.write("\n")

    stream.write("        ")
    stream.write("if not self.context_:\n")
    stream.write("            ")
    stream.write("DIE(1)\n")

    stream.write("        ")
    stream.write("_ctypes.Py_INCREF(self)\n")

def gen_python_method(stream, types, struct_name, retval_type,
                      meth_name, meth_args):

    # Generate the hooks
    c_args = []
    py_args = []
    for argtype, argname in meth_args:
        if argtype.startswith("hook_"):
            for hookname in argname:
                py_args.append(("NEUBOT_" + argtype.upper(), hookname))
                c_args.append(("NEUBOT_" + argtype.upper(),
                    "%s_%s_%s_%s" % (struct_name.upper(), meth_name.upper(),
                                     hookname.upper(), argtype.upper())))
            py_args.append(("Object", "opaque"))
            c_args.append(("Object", "closure"))
        else:
            py_args.append((argtype, argname))
            c_args.append((argtype, argname))

    py_args.insert(0, ("Object", "self"))
    c_args.insert(0, ("Object", "self.context_"))

    gen_python_func_top(stream, types, retval_type, meth_name, py_args)

    for argtype, argname in meth_args:
        if argtype.startswith("hook_"):
            stream.write("\n")
            stream.write("        ")
            stream.write("closure = NeubotHookClosure()\n")
            for hookname in argname:
                stream.write("        ")
                stream.write("closure.functions['%s'] = %s\n" %
                  (hookname, hookname))
            stream.write("        ")
            stream.write("closure.opaque = opaque\n")
            stream.write("        ")
            stream.write("_ctypes.Py_INCREF(closure)\n")
            stream.write("\n")

    stream.write("        ")
    nwritten = 8
    if retval_type != "void":
        stream.write("return ")
        nwritten += 7
    gen_python_callfunc(stream, nwritten, "LIBNEUBOT.%s_%s" %
      (struct_name, meth_name), c_args)
    stream.write("\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)
    stream = sys.stdout

    stream.write("#\n")
    stream.write("# LibNeubot interface - Public domain.\n")
    stream.write("# WARNING: Autogenerated file - do not edit!\n")
    stream.write("#\n")
    stream.write("\n")

    stream.write("# pylint: disable = C0111, C0103\n")
    stream.write("\n")

    gen_python_imports(stream)

    stream.write("DIE = getattr(os, '_exit')\n\n")

    stream.write("NEUBOT_SLOT_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)\n")
    stream.write("\n")
    stream.write("NEUBOT_HOOK_VO = ctypes.CFUNCTYPE(None, ctypes.py_object)\n")
    stream.write("NEUBOT_HOOK_VOS = ctypes.CFUNCTYPE(None, ctypes.py_object,\n")
    stream.write("  ctypes.c_char_p)\n")
    stream.write("\n")

    types = {
        "Object": "ctypes.py_object",
        "cstring": "ctypes.c_char_p",
        "double": "ctypes.c_double",
        "int": "ctypes.c_int",
        "long long": "ctypes.c_longlong",
        "status_t": "ctypes.c_int",
        "void_p": "ctypes.c_void_p",
    }

    # Process all class names once, to register all the types
    for struct_name, _ in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)
        types[struct_name + "_p"] = "ctypes.c_void_p"

    # Process once more, to generate all the prototypes
    for struct_name, methods in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)

        for method_info in methods:
            gen_python_prototype(stream, types, struct_name, method_info)

    stream.write("\n\nclass NeubotHookClosure(object):\n")
    stream.write("    def __init__(self):\n")
    stream.write("        self.opaque = None\n")
    stream.write("        self.functions = {}\n")
    stream.write("\n")

    # Finally, generate the wrapper classes
    for struct_name, methods in sorted(interface["classes"]):
        class_name = struct_name.replace("Neubot", "", 1)

        stream.write("\n\nclass %s(object):\n" % class_name)
        stream.write("\n")

        # Process the methods once, to find the name of the destructor
        destructor_name = None
        for method_info in methods:
            if method_info[0] == "__destruct__":
                destructor_name = method_info[1]
                break

        # Process the methods once more
        for method_info in methods:
            if method_info[0] == "__construct__":

                gen_python_init(stream, types, class_name, struct_name,
                  method_info[1:], destructor_name)

            elif method_info[0] == "__destruct__":
                stream.write("    def %s(self):\n" % method_info[1])
                stream.write("        if not self.context_:\n")
                stream.write("            return\n")
                stream.write("        _ctypes.Py_DECREF(self)\n")
                stream.write("        LIBNEUBOT.%s_%s(self.context_)\n" % (
                  struct_name, method_info[1]))
                stream.write("        self.context_ = None\n")

            else:
                gen_python_method(stream, types, struct_name, method_info[0],
                  method_info[1], method_info[2:])
            gen_python_func_bottom(stream);

if __name__ == "__main__":
    main()
