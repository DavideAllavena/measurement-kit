#!/usr/bin/env python

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

PYLANG_TYPE = {
    "Object": "ctypes.py_object",
    "cstring": "ctypes.c_char_p",
    "double": "ctypes.c_double",
    "int": "ctypes.c_int",
    "long long": "ctypes.c_longlong",
    "status_t": "ctypes.c_int",
    "void_p": "ctypes.c_void_p",
    "void": "None",
}

def pylang_comment(string):
    sys.stdout.write("# %s\n" % string)

def pylang_empty_line():
    sys.stdout.write("\n")

def pylang_write_copyright():
    sys.stdout.write("#\n")
    sys.stdout.write("# LibNeubot interface - Public domain.\n")
    sys.stdout.write("# WARNING: Autogenerated file - do not edit!\n")
    sys.stdout.write("#\n")

def pylang_load_libneubot():
    pylang_empty_line()
    sys.stdout.write("import ctypes\n")
    sys.stdout.write("import sys\n")
    sys.stdout.write("""
if sys.platform == "darwin":
    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.dylib.0"
else:
    LIBNEUBOT_NAME = "/usr/local/lib/libneubot.so.0"

LIBNEUBOT = ctypes.CDLL(LIBNEUBOT_NAME)
""")

def pylang_type(name):
    if name not in PYLANG_TYPE and name.endswith("_p"):
        return "ctypes.c_void_p"
    return PYLANG_TYPE.get(name, name)

def pylang_declare_callback(retval, cbname, params):
    retval = pylang_type(retval)
    uppername = cbname.upper().replace("NEUBOT", "NEUBOT_", 1)
    sys.stdout.write("%s = ctypes.CFUNCTYPE(%s" % (uppername, retval))
    total = len(uppername) + 20 + len(retval)
    for elem in params:
        name, _ = elem
        name = pylang_type(name)
        sys.stdout.write(", ")
        total += 2
        if total + len(name) >= 72:
            sys.stdout.write("\n    ")
            total = 4
        sys.stdout.write("%s" % name)
        total += len(name)
    sys.stdout.write(")\n")
    PYLANG_TYPE[cbname] = uppername

def pylang_declare_class(name):
    sys.stdout.write("# struct %s\n" % name)

def pylang_declare_method(name, method):

    if method[0] == "__construct__":
        retval = name + "_p"
        funcname = name + "_construct"
        args = method[1:]
    else:
        retval = method[0]
        funcname = name + "_" + method[1]
        args = method[2:]
        args.insert(0, (name + "_p", "handle"))

    if retval != "void":
        sys.stdout.write("LIBNEUBOT.%s.restype = %s\n" % (funcname,
          pylang_type(retval)))

    sys.stdout.write("LIBNEUBOT.%s.argtypes = (\n" % funcname)
    if args:
        for elem in args:
            name, _ = elem
            name = pylang_type(name)
            sys.stdout.write("    %s,\n" % name)
    sys.stdout.write(")\n")

    pylang_empty_line()

    sys.stdout.write("def %s(" % funcname)
    total = len(funcname) + 5
    for index, elem in enumerate(args):
        _, value = elem
        if total + len(value) >= 72:
            sys.stdout.write("\n      ")
            total = 6
        sys.stdout.write("%s" % value)
        total += len(value)
        if index < len(args) - 1:
            sys.stdout.write(", ")
            total += 2
    sys.stdout.write("):\n")
    sys.stdout.write("    ")
    total = 4
    if retval != "void":
        sys.stdout.write("ret = ")
        total += 5
    sys.stdout.write("LIBNEUBOT.%s(" % funcname)
    total += len(funcname) + 11
    for index, elem in enumerate(args):
        _, value = elem
        if total + len(value) >= 72:
            sys.stdout.write("\n      ")
            total = 6
        sys.stdout.write("%s" % value)
        total += len(value)
        if index < len(args) - 1:
            sys.stdout.write(", ")
            total += 2
    sys.stdout.write(")\n")
    if retval != "void":
        if retval.endswith("_p"):
            sys.stdout.write("    if not ret:\n")
            sys.stdout.write("        raise RuntimeError('LibNeubot error')\n")
        elif retval == "status_t":
            sys.stdout.write("    if ret != 0:\n")
            sys.stdout.write("        raise RuntimeError('LibNeubot error')\n")
        sys.stdout.write("    return ret\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)

    pylang_write_copyright()

    pylang_empty_line()
    sys.stdout.write("#pylint: disable = C0111, C0103\n")

    pylang_load_libneubot()

    pylang_empty_line()
    pylang_comment("Classes:")
    pylang_empty_line()

    for name in sorted(interface["classes"]):
        pylang_declare_class(name)

    pylang_empty_line()
    pylang_comment("Callbacks:")
    pylang_empty_line()

    for callback in interface["callbacks"]:
        retval = callback[0]
        name = callback[1]
        params = callback[2:]
        pylang_declare_callback(retval, name, params)

    pylang_empty_line()

    for name in sorted(interface["classes"]):
        pylang_comment("%s API:" % name)
        pylang_empty_line()
        for method in interface["classes"][name]:
            pylang_declare_method(name, method)
            pylang_empty_line()

if __name__ == "__main__":
    main()
