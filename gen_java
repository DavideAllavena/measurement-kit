#!/usr/bin/env python

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

JLANG_TYPE = {
    "Object": "long",
    "cstring": "String",
    "void_p": "long",
    "long long": "long",
}

def jlang_comment(string):
    sys.stdout.write("    // %s\n" % string)

def jlang_empty_line():
    sys.stdout.write("\n")

def jlang_write_copyright():
    sys.stdout.write("//\n")
    sys.stdout.write("// LibNeubot interface - Public domain.\n")
    sys.stdout.write("// WARNING: Autogenerated file - do not edit!\n")
    sys.stdout.write("//\n")

def jlang_type(name):
    return JLANG_TYPE.get(name, name)

def jlang_declare_callback(retval, cbname, params):
    JLANG_TYPE[cbname] = "String"
    sys.stdout.write("    //typedef %s (*%s)(" % (retval, cbname))
    for index, elem in enumerate(params):
        name, _ = elem
        name = jlang_type(name)
        sys.stdout.write("%s" % name)
        if index < len(params) - 1:
            sys.stdout.write(", ")
    sys.stdout.write(");\n")

def jlang_declare_class(name):
    sys.stdout.write("    //struct %s;\n" % name)
    JLANG_TYPE[name] = "long"
    JLANG_TYPE[name + "_p"] = "long"

def jlang_declare_method(name, method):

    if method[0] == "__construct__":
        retval = name
        funcname = name + "_construct"
        args = method[1:]
    else:
        retval = method[0]
        funcname = name + "_" + method[1]
        args = method[2:]
        args.insert(0, (name, "self"))

    retval = jlang_type(retval)
    sys.stdout.write("    public final static native %s %s(" % (retval,
                     funcname))
    total = 33 + len(retval) + len(funcname)
    if args:
        for index, elem in enumerate(args):
            name, value = elem
            name = jlang_type(name)
            if total + len(name) + len(value) + 3 >= 78:
                sys.stdout.write("\n        ")
                total = 8
            total += len(name) + len(value) + 3
            sys.stdout.write("%s %s" % (name, value))
            if index < len(args) - 1:
                sys.stdout.write(", ")
                total += 1
    sys.stdout.write(");\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)

    jlang_write_copyright()

    sys.stdout.write("public class LibNeubot {\n")

    jlang_empty_line()
    jlang_comment("")
    jlang_comment("In the following we list the C-level structs and")
    jlang_comment("C-level callbacks, to give you more context.")
    jlang_comment("")

    jlang_empty_line()
    jlang_comment("Structs:")
    jlang_empty_line()

    for name in sorted(interface["classes"]):
        jlang_declare_class(name)

    jlang_empty_line()
    jlang_comment("Callbacks:")
    jlang_empty_line()

    for callback in interface["callbacks"]:
        retval = callback[0]
        name = callback[1]
        params = callback[2:]
        jlang_declare_callback(retval, name, params)

    jlang_empty_line()
    jlang_comment("")
    jlang_comment("Note: in the following there is a number of functions")
    jlang_comment("that in C receive an opaque object and one or more")
    jlang_comment("callback functions; i.e., the callbacks are, in a sense,")
    jlang_comment("bound to the opaque object.")
    jlang_comment("")
    jlang_comment("Because Java does not allow you to take the address of")
    jlang_comment("a function, from Java to C we do not pass the callbacks,")
    jlang_comment("rather we pass their names. Also, the bound opaque object")
    jlang_comment("must be a Java object, and the passed names must refer")
    jlang_comment("to methods of such Java object.")
    jlang_comment("")
    jlang_comment("Also, note that we pass around C opaque objects (i.e.,")
    jlang_comment("address of structures) using the jlong type.")
    jlang_comment("")
    jlang_empty_line()

    for name in sorted(interface["classes"]):
        jlang_comment("%s API:" % name)
        jlang_empty_line()
        for method in interface["classes"][name]:
            jlang_declare_method(name, method)
            jlang_empty_line()

    sys.stdout.write("};\n")

if __name__ == "__main__":
    main()
