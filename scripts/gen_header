#!/usr/bin/env python

#
# Copyright (c) 2013
#     Nexa Center for Internet & Society, Politecnico di Torino (DAUIN)
#     and Simone Basso <bassosimone@gmail.com>.
#
# This file is part of Neubot <http://www.neubot.org/>.
#
# Neubot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Neubot is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Neubot.  If not, see <http://www.gnu.org/licenses/>.
#

# pylint: disable = C0111

import json
import sys

CLANG_TYPE = {
    "Object": "void *",
    "cstring": "const char *",
    "evbuffer_p": "struct evbuffer *",
    "hook_vo": "neubot_hook_vo",
    "hook_vos": "neubot_hook_vos",
    "ioresult_t": "int",
    "slot_vo": "neubot_slot_vo",
    "status_t": "int",
    "string": "char *",
    "void_p": "void *",
}

def clang_comment(string):
    sys.stdout.write("/* %s */\n" % string)

def clang_empty_line():
    sys.stdout.write("\n")

def clang_write_copyright():
    sys.stdout.write("/*\n")
    sys.stdout.write(" * LibIght interface - Public domain.\n")
    sys.stdout.write(" * WARNING: Autogenerated file - do not edit!\n")
    sys.stdout.write(" */\n")

def clang_type(name):
    return CLANG_TYPE.get(name, name)

def clang_declare_class(name):
    sys.stdout.write("struct %s;\n" % name)
    CLANG_TYPE[name] = "struct " + name
    CLANG_TYPE[name + "_p"] = "struct " + name + " *"

def clang_declare_method(name, method):

    if method[0] in ("__construct__", "__static_construct__"):
        retval = name + "_p"
        funcname = name + "_" + method[1]
        args = method[2:]
    elif method[0] == "__destruct__":
        retval = "void"
        funcname = name + "_" + method[1]
        args = method[2:]
        args.insert(0, (name + "_p", "self"))
    else:
        retval = method[0]
        funcname = name + "_" + method[1]
        args = method[2:]
        args.insert(0, (name + "_p", "self"))

    retval = clang_type(retval)
    if retval.endswith("*"):
        space = ""
    else:
        space = " "
    sys.stdout.write("%s%s%s(" % (retval, space, funcname))
    if args:
        total = len(retval) + len(funcname) + 2
        new_args = []
        for argtype, argname in args:
            if argtype.startswith("slot_") or argtype.startswith("hook_"):
                for sh_name in argname:
                    new_args.append((argtype, sh_name))
                new_args.append(("Object", "opaque"))
            else:
                new_args.append((argtype, argname))
        for index, elem in enumerate(new_args):
            name, _ = elem
            name = clang_type(name)
            if index > 0:
                sys.stdout.write(",")
                total += 1
            if total + len(name) >= 78:
                sys.stdout.write("\n    ")
                total = 4
            elif index > 0:
                sys.stdout.write(" ")
                total += 1
            total += len(name)
            sys.stdout.write("%s" % name)
    else:
        sys.stdout.write("void")
    sys.stdout.write(");\n")

def main():
    path = sys.argv[1]
    filep = open(path, "r")
    interface = json.load(filep)

    clang_write_copyright()
    clang_empty_line()

    sys.stdout.write("#ifndef NEUBOT_H\n")
    sys.stdout.write("# define NEUBOT_H\n")
    sys.stdout.write("\n")

    sys.stdout.write("#ifdef __cplusplus\n")
    sys.stdout.write("extern \"C\" {\n")
    sys.stdout.write("#endif\n")
    sys.stdout.write("\n")

    sys.stdout.write("/* Hooks and slots: */\n")
    sys.stdout.write("\n")
    sys.stdout.write("typedef void (*neubot_hook_vo)(void *);\n")
    sys.stdout.write("typedef void (*neubot_hook_vos)(void *, const char *);\n")
    sys.stdout.write("\n")
    sys.stdout.write("typedef void (*neubot_slot_vo)(void *);\n")
    sys.stdout.write("\n")
    sys.stdout.write("struct evbuffer;\n")
    sys.stdout.write("\n")

    clang_comment("Classes:")
    clang_empty_line()

    for name, _ in sorted(interface["classes"]):
        clang_declare_class(name)

    clang_empty_line()

    for name, methods in interface["classes"]:
        clang_comment("%s API:" % name)
        clang_empty_line()

        gettables = {}

        for method in methods:
            if method[0] in ("__construct__", "__static_construct__"):
                new_method = [method[0], method[1]]
                for elem in method[2:]:
                    if len(elem) == 2:
                        new_method.append(elem)
                        continue
                    if len(elem) != 3 or elem[0] != "__gettable__":
                        raise RuntimeError("invalid argument")
                    new_method.append([elem[1], elem[2]])
                    if elem[2] not in gettables:
                        gettables[elem[2]] = elem[1]
                    elif gettables[elem[2]] != elem[1]:
                        raise RuntimeError("inconsistent gettables")
                method = new_method
            elif method[0] == "__object_getter__":
                method = [gettables[method[1]], "get_" + method[1]]
            clang_declare_method(name, method)
            clang_empty_line()

    sys.stdout.write("#ifdef __cplusplus\n")
    sys.stdout.write("}\n")
    sys.stdout.write("#endif\n")
    sys.stdout.write("\n")

    sys.stdout.write("#endif  /* NEUBOT_H */\n")

if __name__ == "__main__":
    main()
